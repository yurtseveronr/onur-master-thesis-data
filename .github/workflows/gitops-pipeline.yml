name: GitOps Pipeline

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: 'AWS Region'
        required: true
        default: 'us-east-1'
        type: string
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production

env:
  AWS_REGION: ${{ github.event.inputs.aws_region || 'us-east-1' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || 'production' }}

permissions:
  id-token: write
  contents: read

jobs:
  gitops-deploy:
    runs-on: [self-hosted]
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Environment
      run: |
        apt-get update && apt-get install -y \
          curl wget unzip git \
          docker.io \
          openjdk-21-jdk

        # Set Java 21
        export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64
        echo "JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64" >> $GITHUB_ENV
        echo "/usr/lib/jvm/java-21-openjdk-amd64/bin" >> $GITHUB_PATH
        
        # Start Docker service
        service docker start || true
        chmod 666 /var/run/docker.sock || true
        
        # Install AWS CLI
        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
        unzip awscliv2.zip
        ./aws/install --update

        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Install ArgoCD CLI
        curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
        install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
        rm argocd-linux-amd64
        
        # Verify installations
        echo "=== CLI Versions ==="
        java -version
        docker --version
        aws --version
        kubectl version --client
        argocd version --client
        echo "===================="
    
    - name: Configure AWS Credentials
      run: |
        aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws configure set default.region ${{ env.AWS_REGION }}
    
    - name: Update EKS Kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name onur-master-eks
        
        # Verify connection
        kubectl cluster-info
        kubectl get nodes
    
    - name: Wait for ArgoCD to be ready
      run: |
        echo "Waiting for ArgoCD to be ready..."
        kubectl wait --for=condition=ready --timeout=600s pods --all -n gitops
        
        # Get ArgoCD admin password
        ARGOCD_PASSWORD=$(kubectl -n gitops get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
        echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV
        
        echo "‚úÖ ArgoCD is ready!"
    
    - name: Login to ArgoCD
      run: |
        # Port forward ArgoCD server
        kubectl port-forward svc/argocd-server -n gitops 8080:443 &
        sleep 10
        
        # Login to ArgoCD
        argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure
        
        echo "‚úÖ Logged in to ArgoCD successfully!"
    
    - name: Update Application Manifests
      run: |
        # Update image tags in Kubernetes manifests based on environment
        if [ "$ENVIRONMENT" = "production" ]; then
          # Update all service images to latest
          kubectl set image deployment/authentication-service authentication-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/authentication-service:latest -n authentication --dry-run=client -o yaml > /tmp/auth-update.yaml
          kubectl set image deployment/user-service user-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/user-service:latest -n user --dry-run=client -o yaml > /tmp/user-update.yaml
          kubectl set image deployment/movie-service movie-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/movie-service:latest -n movies --dry-run=client -o yaml > /tmp/movie-update.yaml
          kubectl set image deployment/series-service series-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/series-service:latest -n series --dry-run=client -o yaml > /tmp/series-update.yaml
          kubectl set image deployment/search-service search-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/search-service:latest -n search --dry-run=client -o yaml > /tmp/search-update.yaml
          kubectl set image deployment/frontend frontend=708778582346.dkr.ecr.us-east-1.amazonaws.com/frontend:latest -n frontend --dry-run=client -o yaml > /tmp/frontend-update.yaml
          kubectl set image deployment/bedrock-backend bedrock-backend=708778582346.dkr.ecr.us-east-1.amazonaws.com/bedrock-backend:latest -n bedrock --dry-run=client -o yaml > /tmp/bedrock-update.yaml
          kubectl set image deployment/machine-learning-service machine-learning-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/machine-learning-service:latest -n ml --dry-run=client -o yaml > /tmp/ml-update.yaml
          kubectl set image deployment/kinesis-producer kinesis-producer=708778582346.dkr.ecr.us-east-1.amazonaws.com/kinesis-producer:latest -n kinesis --dry-run=client -o yaml > /tmp/producer-update.yaml
          kubectl set image deployment/kinesis-consumer kinesis-consumer=708778582346.dkr.ecr.us-east-1.amazonaws.com/kinesis-consumer:latest -n kinesis --dry-run=client -o yaml > /tmp/consumer-update.yaml
        else
          # For staging, use staging tags
          kubectl set image deployment/authentication-service authentication-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/authentication-service:staging -n authentication --dry-run=client -o yaml > /tmp/auth-update.yaml
          kubectl set image deployment/user-service user-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/user-service:staging -n user --dry-run=client -o yaml > /tmp/user-update.yaml
          kubectl set image deployment/movie-service movie-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/movie-service:staging -n movies --dry-run=client -o yaml > /tmp/movie-update.yaml
          kubectl set image deployment/series-service series-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/series-service:staging -n series --dry-run=client -o yaml > /tmp/series-update.yaml
          kubectl set image deployment/search-service search-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/search-service:staging -n search --dry-run=client -o yaml > /tmp/search-update.yaml
          kubectl set image deployment/frontend frontend=708778582346.dkr.ecr.us-east-1.amazonaws.com/frontend:staging -n frontend --dry-run=client -o yaml > /tmp/frontend-update.yaml
          kubectl set image deployment/bedrock-backend bedrock-backend=708778582346.dkr.ecr.us-east-1.amazonaws.com/bedrock-backend:staging -n bedrock --dry-run=client -o yaml > /tmp/bedrock-update.yaml
          kubectl set image deployment/machine-learning-service machine-learning-service=708778582346.dkr.ecr.us-east-1.amazonaws.com/machine-learning-service:staging -n ml --dry-run=client -o yaml > /tmp/ml-update.yaml
          kubectl set image deployment/kinesis-producer kinesis-producer=708778582346.dkr.ecr.us-east-1.amazonaws.com/kinesis-producer:staging -n kinesis --dry-run=client -o yaml > /tmp/producer-update.yaml
          kubectl set image deployment/kinesis-consumer kinesis-consumer=708778582346.dkr.ecr.us-east-1.amazonaws.com/kinesis-consumer:staging -n kinesis --dry-run=client -o yaml > /tmp/consumer-update.yaml
        fi
        
        echo "‚úÖ Updated application manifests for $ENVIRONMENT environment"
    
    - name: Sync Specific ArgoCD Applications
      run: |
        echo "Syncing specific ArgoCD applications based on environment..."
        
        # Sync only the applications that were updated
        if [ "$ENVIRONMENT" = "production" ]; then
          # Sync all production applications
          APPLICATIONS=("authentication-service" "user-service" "movie-service" "series-service" "search-service" "frontend" "bedrock-backend" "machine-learning-service" "kinesis-producer" "kinesis-consumer")
        else
          # For staging, sync only specific applications
          APPLICATIONS=("authentication-service" "user-service" "movie-service" "series-service")
        fi
        
        for app in "${APPLICATIONS[@]}"; do
          echo "Syncing application: $app"
          argocd app sync $app --prune --force || echo "‚ö†Ô∏è Failed to sync $app, continuing..."
          
          # Wait for sync to complete
          argocd app wait $app --health --timeout=300 || echo "‚ö†Ô∏è Health check failed for $app, continuing..."
          
          echo "‚úÖ Application $app synced successfully!"
        done
        
        echo "‚úÖ Selected applications synced!"
    
    - name: Verify Deployments
      run: |
        echo "Verifying all deployments..."
        
        # Check all namespaces
        NAMESPACES="authentication user movies series search frontend bedrock ml kinesis"
        
        for ns in $NAMESPACES; do
          echo "Checking namespace: $ns"
          kubectl get pods -n $ns
          kubectl get deployments -n $ns
          
          # Wait for all pods to be ready
          kubectl wait --for=condition=ready --timeout=300s pods --all -n $ns || echo "‚ö†Ô∏è Some pods in $ns namespace are not ready"
        done
        
        echo "‚úÖ Deployment verification completed!"
    

    
    - name: Rollback on Failure
      if: failure()
      run: |
        echo "üö® Deployment failed! Initiating rollback..."
        
        # Rollback all applications to previous version
        APPLICATIONS=$(argocd app list -o name)
        
        for app in $APPLICATIONS; do
          echo "Rolling back application: $app"
          argocd app rollback $app
        done
        
        echo "‚úÖ Rollback completed!"
        
        # Send notification (you can add Slack, email, etc.)
        echo "Rollback notification sent!" 