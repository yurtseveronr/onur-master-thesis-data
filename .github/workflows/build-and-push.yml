name: Build and Push Docker Images to ECR

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: 'AWS Region'
        required: true
        default: 'us-east-1'
        type: string

env:
  AWS_REGION: ${{ github.event.inputs.aws_region || 'us-east-1' }}
  AWS_ACCOUNT_ID: '708778582346'

permissions:
  id-token: write
  contents: read

jobs:
  network-and-ecr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}
      - name: Deploy S3/Network CloudFormation Stack
        run: |
          if aws cloudformation describe-stacks --stack-name network-stack --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Stack 'network-stack' already exists. Skipping deploy."
          else
            aws cloudformation deploy \
              --template-file cloudformation_templates/network-stack.yml \
              --stack-name network-stack \
              --region ${{ env.AWS_REGION }} \
              --capabilities CAPABILITY_NAMED_IAM
          fi
      - name: Deploy ECR CloudFormation Stack
        run: |
          if aws cloudformation describe-stacks --stack-name ecr --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Stack 'ecr' already exists. Skipping deploy."
          else
            aws cloudformation deploy \
              --template-file cloudformation_templates/ecr.yml \
              --stack-name ecr \
              --region ${{ env.AWS_REGION }} \
              --capabilities CAPABILITY_NAMED_IAM
          fi
      - name: Deploy Authentication CloudFormation Stack
        run: |
          if aws cloudformation describe-stacks --stack-name authentication --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Stack 'authentication' already exists. Skipping deploy."
          else
            aws cloudformation deploy \
              --template-file cloudformation_templates/authentication_service.yml \
              --stack-name authentication \
              --region ${{ env.AWS_REGION }} \
              --capabilities CAPABILITY_NAMED_IAM \
              --parameter-overrides AppName=auth-app AwsRegion=${{ env.AWS_REGION }}
          fi

  build-authentication:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check files
        run: |
          pwd
          ls -la
          ls -la services/authentication-service

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Clear Docker cache
        run: |
          echo "Clearing Docker cache..."
          docker system prune -f
          docker builder prune -f
          docker image prune -f

      - name: Build and push authentication-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: authentication-service
          IMAGE_TAG: latest
        run: |
          echo "Building authentication-service..."
          # Use absolute path to be sure
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f $(pwd)/services/authentication-service/Dockerfile $(pwd)/services/authentication-service/
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ authentication-service pushed successfully"

  build-user:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push user-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: user-service
          IMAGE_TAG: latest
        run: |
          echo "Building user-service..."
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f services/user-service/Dockerfile services/user-service
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ user-service pushed successfully"

  build-movies:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push movies-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: movies-service
          IMAGE_TAG: latest
        run: |
          echo "Building movies-service..."
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f services/movie-service/movie-service/Dockerfile services/movie-service/movie-service
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ movies-service pushed successfully"

  build-series:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push series-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: series-service
          IMAGE_TAG: latest
        run: |
          echo "Building series-service..."
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f services/series-service/series-service/Dockerfile services/series-service/series-service
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ series-service pushed successfully"

  build-search:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push search-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: search-service
          IMAGE_TAG: latest
        run: |
          echo "Building search-service..."
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f services/search-service/Dockerfile services/search-service
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ search-service pushed successfully"

  build-frontend:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Clear Docker cache
        run: |
          echo "Clearing Docker cache..."
          docker system prune -f
          docker builder prune -f
          docker image prune -f

      - name: Debug frontend path
        run: |
          echo "Current directory: $(pwd)"
          echo "Checking frontend service path..."
          ls -la services/frontend/
          echo ""
          echo "Checking Dockerfile..."
          ls -la services/frontend/Dockerfile

      - name: Build and push frontend-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: frontend-service
          IMAGE_TAG: latest
        run: |
          echo "Building frontend-service..."
          # Use absolute path and add retry for apt-get
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f $(pwd)/services/frontend/Dockerfile $(pwd)/services/frontend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ frontend-service pushed successfully"

  build-chatbot:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push chatbot-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: chatbot-service
          IMAGE_TAG: latest
        run: |
          echo "Building chatbot-service..."
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f services/bedrock_backend/Dockerfile services/bedrock_backend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ chatbot-service pushed successfully"

  build-personalize:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push personalize-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: personalize-service
          IMAGE_TAG: latest
        run: |
          echo "Building personalize-service..."
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f services/machine_learning_service/Dockerfile services/machine_learning_service
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ personalize-service pushed successfully"

  build-producer:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push producer-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: producer-service
          IMAGE_TAG: latest
        run: |
          echo "Building producer-service..."
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f services/kinesis-producer/Dockerfile services/kinesis-producer
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ producer-service pushed successfully"

  build-consumer:
    runs-on: ubuntu-latest
    needs: network-and-ecr
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Clear Docker cache
        run: |
          echo "Clearing Docker cache..."
          docker system prune -f
          docker builder prune -f
          docker image prune -f

      - name: Build and push consumer-service
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: consumer-service
          IMAGE_TAG: latest
        run: |
          echo "Building consumer-service..."
          # Force rebuild without any cache
          docker build --no-cache --pull --force-rm --progress=plain -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -f services/kinesis-consumer/Dockerfile services/kinesis-consumer
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "✅ consumer-service pushed successfully" 

  deploy-eks-and-k8s:
    runs-on: ubuntu-latest
    needs:
      - build-authentication
      - build-user
      - build-movies
      - build-series
      - build-search
      - build-frontend
      - build-chatbot
      - build-personalize
      - build-producer
      - build-consumer
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::708778582346:role/onur-github-role
          aws-region: ${{ env.AWS_REGION }}
      - name: Deploy EKS Cluster
        run: |
          if aws cloudformation describe-stacks --stack-name eks --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Stack 'eks' already exists. Skipping deploy."
          else
            aws cloudformation deploy \
              --template-file cloudformation_templates/eks.yml \
              --stack-name eks \
              --region ${{ env.AWS_REGION }} \
              --capabilities CAPABILITY_NAMED_IAM
          fi
      - name: Deploy EKS Add-ons
        run: |
          if aws cloudformation describe-stacks --stack-name eks-add-ons --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Stack 'eks-add-ons' already exists. Skipping deploy."
          else
            aws cloudformation deploy \
              --template-file cloudformation_templates/eks-add-ons.yml \
              --stack-name eks-add-ons \
              --region ${{ env.AWS_REGION }} \
              --capabilities CAPABILITY_NAMED_IAM
          fi
      - name: Install kubectl
        run: |
          curl -sSL -o kubectl https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl
          kubectl version --client
      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name onur-master-eks
      - name: Create Namespaces
        run: |
          kubectl apply -f kubernetes_manifest/namespaces.yml
      - name: Create Service Accounts
        run: |
          kubectl apply -f kubernetes_manifest/service_accounts.yml
      - name: Ensure AWS Load Balancer Controller IAM Policy
        run: |
          set -e
          POLICY_NAME="AWSLoadBalancerControllerIAMPolicy"
          POLICY_ARN=$(aws iam list-policies --scope Local --query "Policies[?PolicyName=='${POLICY_NAME}'].Arn" --output text)
          if [ -z "$POLICY_ARN" ]; then
            curl -sS -o iam_policy.json "https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.13.3/docs/install/iam_policy.json"
            aws iam create-policy --policy-name "${POLICY_NAME}" --policy-document file://iam_policy.json
          fi
      - name: Create Ingress Controller
        run: |
          chmod +x scripts/install_load_balancer_controller.sh
          bash scripts/install_load_balancer_controller.sh
      - name: Create Pod Identity Associations
        run: |
          if aws cloudformation describe-stacks --stack-name eks_pod_identity --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Stack 'eks_pod_identity' already exists. Skipping deploy."
          else
            aws cloudformation deploy \
              --template-file cloudformation_templates/eks_pod_identity.yml \
              --stack-name eks_pod_identity \
              --region ${{ env.AWS_REGION }} \
              --capabilities CAPABILITY_NAMED_IAM
          fi
      - name: Apply Ingress resources
        run: |
          kubectl apply -f kubernetes_manifest/ingress.yml
      - name: Deploy Services to EKS
        run: |
          kubectl apply -f kubernetes_manifest/services
      - name: Deploy DevOps
        run: |
          kubectl apply -f kubernetes_manifest/devops/devops.yml
      - name: Deploy GitOps/ArgoCD
        run: |
          kubectl apply -k kubernetes_manifest/gitops/ 